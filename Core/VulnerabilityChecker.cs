using System.Net;
using VulScan.Modules;
using VulScan.Utilities;

namespace VulScan.Core;

public class VulnerabilityChecker
{
    public static async Task CheckAsync(string vulName, string url, Request request)
    {
        // 1.发送HTTP请求
        string pocUrl = UrlUtility.JoinUrl(url, request.URL);
        HttpMethod httpMethod = new HttpMethod(request.Method);
        string requestBody = request.Body;
        string userAgent = request.UserAgent;

        HttpResponseMessage httpResponseMessage = await HttpService.SendHttpRequestAsync(pocUrl, httpMethod, requestBody, userAgent);
        
        // 2.分析响应
        if (httpResponseMessage != null)
        {
            HttpStatusCode httpStatusCode = httpResponseMessage.StatusCode;
            string responseBody = new StreamReader(httpResponseMessage.Content.ReadAsStream()).ReadToEnd();
        
            if (HttpService.HandleHttpResponse(vulName, httpStatusCode, responseBody))
            {
                WriteFileUtility.AddNewOutputJson(pocUrl, requestBody, responseBody);
                ColorUtility.PrintColored($"[*]目标 {url} 存在漏洞 {vulName}", ColorType.Red);
                ExploitExecutor.VulExploit(vulName, requestBody, responseBody);
            }
            else
            {
                ColorUtility.PrintColored($"[-]目标 {url} 无漏洞", ColorType.Default);
            }
        }
    }
}